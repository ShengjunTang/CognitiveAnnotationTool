<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸‰ç»´æ¨¡å‹è´¨é‡è®¤çŸ¥å®éªŒå¹³å° (Cognitive Experiment)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #1a1a1a; color: #fff; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #login-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; justify-content: center; align-items: center;
            z-index: 2000; flex-direction: column;
        }
        .login-box { width: 400px; padding: 40px; background: #222; border: 1px solid #444; border-radius: 8px; text-align: center; pointer-events: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.8); }
        .login-input { width: 80%; padding: 10px; margin: 15px 0; background: #333; border: 1px solid #555; color: white; border-radius: 4px; font-size: 16px; }
        
        #experiment-bar {
            position: absolute; top: 0; left: 0; width: 100%; height: 60px;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 100%);
            display: flex; justify-content: center; align-items: center;
            z-index: 100; pointer-events: none;
        }
        .stage-indicator {
            background: rgba(0,0,0,0.6); padding: 10px 30px; border-radius: 30px;
            border: 1px solid #444; pointer-events: auto; display: flex; gap: 20px; align-items: center;
        }
        .stage-step { opacity: 0.3; font-weight: bold; font-size: 14px; }
        .stage-step.active { opacity: 1; color: #00d2ff; text-shadow: 0 0 10px rgba(0, 210, 255, 0.5); transform: scale(1.1); }
        
        #ui-layer {
            position: absolute; top: 80px; right: 20px; width: 320px;
            background: rgba(0, 0, 0, 0.85); padding: 20px; border-radius: 8px;
            backdrop-filter: blur(8px); border: 1px solid #444;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5); z-index: 10;
            max-height: 85vh; overflow-y: auto;
        }

        h2 { margin-top: 0; font-size: 16px; color: #00d2ff; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid #444; padding-bottom: 10px; margin-bottom: 15px; }
        .control-group { margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 15px; }
        .stat-row { display: flex; justify-content: space-between; font-size: 13px; margin-bottom: 5px; }
        .stat-val { font-weight: bold; color: #fff; }

        button.action-btn, .tool-btn {
            width: 100%; padding: 10px; background: #2c3e50; border: 1px solid #444; color: white;
            cursor: pointer; border-radius: 4px; transition: 0.2s; margin-top: 5px; font-weight: 500;
        }
        button.action-btn:hover, .tool-btn:hover { background: #34495e; border-color: #00d2ff; }
        button.action-btn:disabled { background: #444; color: #666; border-color: #444; cursor: not-allowed; }
        button.primary { background: #00d2ff; color: #000; font-weight: bold; border: none; }
        button.primary:hover { background: #00b5dc; }
        button.next-stage { background: #27ae60; color: white; font-weight: bold; border: none; margin-top: 20px; padding: 15px; }
        button.next-stage:hover { background: #2ecc71; }
        button.danger { background: #c0392b; border: none; }
        button.danger:hover { background: #e74c3c; }
        button.outline { background: transparent; border: 1px solid #00d2ff; color: #00d2ff; }
        button.outline:hover { background: rgba(0, 210, 255, 0.1); }
        
        .tool-bar { display: flex; gap: 5px; margin-bottom: 10px; }
        .tool-btn { flex: 1; margin-top: 0; font-size: 18px; color: #888; }
        .tool-btn.active { background: #00d2ff; color: #000; border-color: #00d2ff; }
        
        /* è§†è§’æŒ‰é’®ç½‘æ ¼ */
        .view-grid { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; margin-top: 5px; }
        .view-grid button { margin-top: 0; padding: 8px 0; font-size: 12px; }

        .tool-setting { display: flex; align-items: center; justify-content: space-between; font-size: 12px; margin-top: 8px; color: #ccc; }
        .tool-setting input { width: 60px; background: #222; border: 1px solid #555; color: white; padding: 2px 5px; border-radius: 3px; }

        /* åˆ†æé¢æ¿æ ·å¼ (ä¿®å¤ï¼šå±…ä¸­æ˜¾ç¤º) */
        #analysis-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); z-index: 1999; display: none;
            backdrop-filter: blur(5px);
        }
        #analysis-panel {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 350px; background: rgba(0, 0, 0, 0.95); padding: 30px; 
            border-radius: 12px; border: 1px solid #00d2ff; 
            box-shadow: 0 0 40px rgba(0, 210, 255, 0.3); z-index: 2000;
        }
        .viz-option { margin-bottom: 15px; display: flex; align-items: center; justify-content: space-between; font-size: 14px; }
        .viz-legend { display: flex; gap: 10px; font-size: 12px; margin-top: 10px; justify-content: center; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .color-box { width: 12px; height: 12px; border-radius: 3px; }
        #close-analysis { position: absolute; top: 10px; right: 15px; cursor: pointer; font-size: 20px; color: #888; }
        #close-analysis:hover { color: white; }

        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center;
            z-index: 999; flex-direction: column; pointer-events: auto;
        }
        .spinner { width: 40px; height: 40px; border: 4px solid #333; border-top: 4px solid #00d2ff; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        #bottom-bar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85); padding: 10px 25px; border-radius: 50px;
            display: flex; align-items: center; gap: 20px; border: 1px solid #444; z-index: 10;
            backdrop-filter: blur(5px); box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .slider-container { display: flex; align-items: center; gap: 10px; }
        input[type="range"] { accent-color: #00d2ff; }
        
        #cursor-feedback { position: fixed; pointer-events: none; padding: 5px 10px; background: rgba(0,0,0,0.7); border-radius: 4px; font-size: 12px; display: none; z-index: 1000; border: 1px solid #555; }
        #brush-cursor { position: fixed; pointer-events: none; border-radius: 50%; border: 2px dashed rgba(0, 210, 255, 0.8); background: rgba(0, 210, 255, 0.1); transform: translate(-50%, -50%); display: none; z-index: 998; }
        #focus-msg { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0, 210, 255, 0.2); border: 1px solid #00d2ff; padding: 15px 30px; color: #fff; font-weight: bold; border-radius: 30px; pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 2000; }
        #file-input { display: none; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- 1. ç™»å½•ç•Œé¢ -->
    <div id="login-overlay" class="overlay-panel">
        <div class="login-box">
            <h2 style="border:none;">ğŸ§ª è®¤çŸ¥å®éªŒå‡†å¤‡</h2>
            <p>è¯·è¾“å…¥å‚ä¸è€… ID ä»¥å¼€å§‹è®°å½•æ•°æ®ã€‚</p>
            <input type="text" id="user-id-input" class="login-input" placeholder="User ID (e.g., P01)">
            
            <p style="text-align:left; font-size:12px; color:#888; margin-top:20px;">
                <b>å®éªŒè¯´æ˜ï¼š</b><br>
                1. æœ¬å®éªŒåˆ†ä¸‰ä¸ªé˜¶æ®µï¼Œè¯·æŒ‰æç¤ºæ“ä½œã€‚<br>
                2. è¯·å°½å¯èƒ½å‡†ç¡®åœ°æ ‡è®°æ‚¨è®¤ä¸ºçš„æ¨¡å‹ç¼ºé™·ã€‚<br>
                3. æ‚¨çš„æ‰€æœ‰æ“ä½œï¼ˆè§†è§’ç§»åŠ¨ã€æ ‡è®°ã€æ’¤é”€ï¼‰éƒ½å°†è¢«è®°å½•ã€‚
            </p>
            
            <div style="height: 10px;"></div>
            <input type="file" id="init-file-input" multiple accept=".obj,.mtl,.glb,.gltf,.png,.jpg,.jpeg" style="display:none">
            <button class="primary action-btn" id="start-experiment-btn">ğŸš€ åŠ è½½æ¨¡å‹å¹¶å¼€å§‹</button>
            <button class="action-btn" onclick="document.getElementById('init-file-input').click()">ğŸ“‚ é€‰æ‹©æ¨¡å‹æ–‡ä»¶</button>
            <button class="action-btn outline" id="demo-model-btn" style="margin-top:10px; font-size:12px;">ğŸ² ä½¿ç”¨å†…ç½®æ¼”ç¤ºæ¨¡å‹</button>
        </div>
    </div>

    <!-- 2. å®éªŒè¿›åº¦æ¡ -->
    <div id="experiment-bar">
        <div class="stage-indicator">
            <div class="stage-step" id="step-1">1. çº¯å‡ ä½•è§‚å¯Ÿ</div>
            <div style="color:#444">â”</div>
            <div class="stage-step" id="step-2">2. çº¹ç†è§‚å¯Ÿ</div>
            <div style="color:#444">â”</div>
            <div class="stage-step" id="step-3">3. ç»¼åˆæ ¡éªŒ</div>
        </div>
    </div>

    <div id="loading-overlay">
        <div class="spinner"></div>
        <div style="color:white">æ•°æ®å¤„ç†ä¸­...</div>
    </div>
    
    <div id="focus-msg">ğŸ¯ è§†è§’å·²èšç„¦</div>
    <div id="brush-cursor"></div>
    <div id="canvas-container"></div>
    <div id="cursor-feedback">Face ID: --</div>

    <!-- 3. åˆ†æé¢æ¿ (åŒ…å«é®ç½©å±‚) -->
    <div id="analysis-overlay">
        <div id="analysis-panel">
            <div id="close-analysis">Ã—</div>
            <h2 style="margin-top:0">ğŸ“Š æ•°æ®å¯è§†åŒ–åˆ†æ</h2>
            <p style="color:#aaa; font-size:12px; margin-bottom:20px;">å®éªŒå·²ç»“æŸã€‚è¯·é€‰æ‹©å¯è§†åŒ–æ¨¡å¼æŸ¥çœ‹æ‚¨çš„è®¤çŸ¥è½¨è¿¹ã€‚</p>
            
            <div class="control-group">
                <div class="viz-option">
                    <span>æ˜¾ç¤ºè½¨è¿¹çº¿:</span>
                    <input type="checkbox" id="viz-traj" checked>
                </div>
                <div class="viz-option">
                    <span>æ˜¾ç¤ºäº¤äº’é”šç‚¹:</span>
                    <input type="checkbox" id="viz-markers" checked>
                </div>
            </div>
            
            <div class="control-group">
                <p style="color:#00d2ff; font-weight:bold;">ğŸ¨ æ¨¡å‹å±æ€§ç€è‰²</p>
                <button class="action-btn" id="viz-mode-default">ğŸ”´ é»˜è®¤ (çº¢/ç°)</button>
                <button class="action-btn" id="viz-mode-stage">ğŸŒˆ æŒ‰å‘ç°é˜¶æ®µ (è“/ç»¿/çº¢)</button>
                <button class="action-btn" id="viz-mode-hesitation">â±ï¸ æŒ‰æ³¨è§†æ—¶é—´ (Heatmap)</button>
                <button class="action-btn" id="viz-mode-conf">ğŸ§  æŒ‰ç¡®ä¿¡åº¦ (Heatmap)</button>
                
                <div id="legend-stage" class="viz-legend" style="display:none;">
                    <div class="legend-item"><div class="color-box" style="background:#0000ff"></div>S1(Geo)</div>
                    <div class="legend-item"><div class="color-box" style="background:#00ff00"></div>S2(Tex)</div>
                    <div class="legend-item"><div class="color-box" style="background:#ff0000"></div>S3(Mix)</div>
                </div>
            </div>
            
            <button class="primary action-btn" id="final-export-btn">ğŸ’¾ å¯¼å‡ºå®éªŒæ•°æ® (JSON)</button>
        </div>
    </div>

    <!-- 4. å³ä¾§æ“ä½œé¢æ¿ -->
    <div id="ui-layer" style="display:none;"> 
        <h2 id="stage-title">é˜¶æ®µ 1: çº¯å‡ ä½•æ ‡è®°</h2>
        <p id="stage-desc">è¯·ä»…æ ¹æ®å‡ ä½•ç»“æ„ï¼ˆç™½æ¨¡ï¼‰æ ‡è®°æ¨¡å‹ç¼ºé™·ã€‚å¿½ç•¥çº¹ç†ä¿¡æ¯ã€‚</p>

        <div class="control-group">
            <div class="stat-row"><span>å·²æ ‡æ³¨é¢ç‰‡:</span><span class="stat-val" id="count-val">0</span></div>
            <div class="stat-row"><span>å½“å‰é˜¶æ®µæ ‡è®°:</span><span class="stat-val" id="stage-count-val">0</span></div>
        </div>

        <!-- å¿«é€Ÿè§†è§’åˆ‡æ¢ -->
        <div class="control-group">
            <p style="color:#00d2ff; font-weight:bold;">ğŸ”­ å¿«é€Ÿè§†è§’</p>
            <div class="view-grid">
                <button class="tool-btn" id="view-top" title="é¡¶è§†å›¾">Top</button>
                <button class="tool-btn" id="view-front" title="æ­£è§†å›¾">Front</button>
                <button class="tool-btn" id="view-right" title="å³è§†å›¾">Right</button>
                <button class="tool-btn" id="view-bottom" title="åº•è§†å›¾">Bottom</button>
                <button class="tool-btn" id="view-back" title="åè§†å›¾">Back</button>
                <button class="tool-btn" id="view-left" title="å·¦è§†å›¾">Left</button>
            </div>
        </div>

        <div class="control-group">
            <p style="color:#00d2ff; font-weight:bold;">ğŸ› ï¸ æ ‡æ³¨å·¥å…·</p>
            <div class="tool-bar">
                <div class="tool-btn active" id="tool-point" title="ç‚¹é€‰">ğŸ–±ï¸</div>
                <div class="tool-btn" id="tool-brush" title="ç¬”åˆ·">ğŸ–Œï¸</div>
                <div class="tool-btn" id="tool-wand" title="é­”æ£’">ğŸª„</div>
            </div>
            <!-- å‚æ•°é¢æ¿ -->
            <div id="param-brush" class="tool-setting" style="display:none;">
                <span>ç¬”åˆ·åŠå¾„:</span> 
                <input type="range" id="brush-size" min="0.5" max="10.0" step="0.5" value="2.0">
                <span id="brush-size-val">2.0</span>
            </div>
            <div id="param-wand" class="tool-setting" style="display:none;">
                <span>æ³•çº¿å®¹å·®(Â°):</span> 
                <input type="number" id="wand-angle" min="1" max="90" value="20">
            </div>
            <div style="font-size:11px; color:#888; margin-top:5px;">*æŒ‰ä½ Shift åˆ é™¤æ ‡è®° (æ‰€æœ‰å·¥å…·é€šç”¨)</div>
        </div>

        <div class="control-group">
            <button class="action-btn" id="undo-btn" disabled>â†©ï¸ æ’¤é”€ (Ctrl+Z)</button>
            <button class="action-btn" id="toggle-bg-btn">ğŸ¨ èƒŒæ™¯: æ·±è‰²</button>
            <button class="action-btn" id="toggle-ctrl-btn">ğŸ•¹ï¸ è§†è§’ï¼šè‡ªç”± (3è½´)</button>
            <!-- éšè—äº†æ‰‹åŠ¨åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼çš„æŒ‰é’®ï¼Œç”±å®éªŒæµç¨‹å¼ºåˆ¶æ§åˆ¶ -->
            <button class="action-btn" id="toggle-mode-btn" style="display:none">ğŸ‘ï¸ è°ƒè¯•: åˆ‡æ¢æ˜¾ç¤º</button>
            <button class="action-btn" id="toggle-opacity-btn" style="display:none">ğŸ’§ è°ƒè¯•: åŠé€æ˜</button>
        </div>
        
        <div class="control-group">
             <button class="action-btn outline" id="export-obj-btn">ğŸ“¦ å¯¼å‡ºå½©è‰²æ¨¡å‹ (.obj)</button>
             <button class="action-btn outline" id="export-json-btn">ğŸ’¾ å¯¼å‡º: æ ‡æ³¨æ•°æ® (.json)</button>
        </div>

        <button class="next-stage" id="next-stage-btn">âœ… å®Œæˆæœ¬é˜¶æ®µï¼Œä¸‹ä¸€æ­¥</button>
        
        <input type="file" id="file-input" multiple accept=".obj,.mtl,.glb,.gltf,.png,.jpg,.jpeg" style="display:none">
        <button class="action-btn" onclick="document.getElementById('file-input').click()" style="margin-top:10px;">ğŸ“‚ é‡æ–°åŠ è½½æ¨¡å‹</button>
    </div>

    <!-- åº•éƒ¨ç½®ä¿¡åº¦æ¡ -->
    <div id="bottom-bar" style="display:none;">
        <div class="slider-container">
            <span>ğŸ§  ç¡®ä¿¡åº¦:</span>
            <span style="font-size:12px; opacity:0.7">çŠ¹è±«</span>
            <input type="range" id="confidence-slider" min="0" max="100" value="100">
            <span style="font-size:12px; opacity:0.7">ç¡®ä¿¡</span>
            <span id="conf-display" style="font-weight:bold; color:#00d2ff; width: 30px">100%</span>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { ArcballControls } from 'three/addons/controls/ArcballControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js'; 
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js'; 
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        // --- å…¨å±€å˜é‡å£°æ˜ ---
        let scene, camera, renderer;
        let currentControls, orbitControls, arcballControls; 
        let raycaster, mouse;
        let currentMesh = null;
        let originalColorAttribute = null; 
        let objectURLs = [];
        let mouseDownPosition = new THREE.Vector2(); 

        let trajLines = null;
        let actionMarkersGroup = null;
        let gazeSpheresGroup = null;
        let seqTextGroup = null;

        let hoveredFaceIndex = -1;
        let hoverStartTime = 0;
        let hoverInteractionCount = 0;
        let totalMarked = 0;
        
        let isFocusing = false;
        let focusTargetPos = new THREE.Vector3();
        let focusCameraPos = new THREE.Vector3();
        let focusCameraUp = new THREE.Vector3(0, 1, 0); // For smooth transition
        
        let displayMode = 2; // Default to Grid for Stage 1
        let currentTool = 'point';
        let brushRadius = 2.0;
        let wandAngleThreshold = 20;

        let annotationData = {}; 
        let undoStack = []; 
        let adjacencyMap = null; 
        
        let autoStartExperiment = false; 
        let lastLogTime = 0; 
        let isInteractWithModel = false; 
        let isDarkBackground = true;

        let experimentConfig = {
            userId: "Anonymous",
            startTime: null,
            currentStage: 0, 
            logs: [] 
        };

        // --- Core Helper Functions ---
        function logInteraction(type, details = {}) {
            const now = Date.now();
            if (type === 'camera_move' && now - lastLogTime < 200) return; 
            if (type === 'camera_move') lastLogTime = now;

            const logEntry = {
                t: now, s: experimentConfig.currentStage, a: type,
                cam: { 
                    p: camera.position.toArray().map(v=>parseFloat(v.toFixed(2))),
                    r: camera.rotation.toArray().slice(0,3).map(v=>parseFloat(v.toFixed(2))),
                    t: currentControls && currentControls.target ? currentControls.target.toArray().map(v=>parseFloat(v.toFixed(2))) : [0,0,0]
                },
                d: details
            };
            experimentConfig.logs.push(logEntry);
        }

        function safeBind(id, event, handler) {
            const el = document.getElementById(id);
            if (el) el.addEventListener(event, handler);
        }

        function cleanGeometry(geometry) {
            const posAttr = geometry.attributes.position;
            const count = posAttr.count;
            let hasNaN = false;
            for(let i=0; i<count; i++) {
                const x = posAttr.getX(i); const y = posAttr.getY(i); const z = posAttr.getZ(i);
                if (isNaN(x) || isNaN(y) || isNaN(z) || !isFinite(x) || !isFinite(y) || !isFinite(z)) {
                    posAttr.setXYZ(i, 0, 0, 0); hasNaN = true;
                }
            }
            if (hasNaN) posAttr.needsUpdate = true;
        }

        function createTextSprite(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64; canvas.height = 64;
            ctx.fillStyle = "white";
            ctx.font = "Bold 40px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 4;
            ctx.strokeText(text, 32, 32);
            ctx.fillText(text, 32, 32);
            const texture = new THREE.CanvasTexture(canvas);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, depthTest: false }));
            sprite.scale.set(2, 2, 1);
            return sprite;
        }

        window.onerror = function(message, source, lineno, colno, error) {
            console.error(error);
            alert(`ç¨‹åºå‡ºé”™: ${message}\nè¯·æ£€æŸ¥æ§åˆ¶å°ã€‚`);
        };

        window.addEventListener('DOMContentLoaded', () => {
            init();
            animate();
        });

        function init() {
            const container = document.getElementById('canvas-container');
            const brushSizeInput = document.getElementById('brush-size');
            const brushSizeVal = document.getElementById('brush-size-val');
            const wandAngleInput = document.getElementById('wand-angle');
            const confDisplay = document.getElementById('conf-display');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            scene.add(new THREE.AxesHelper(50));

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000); 
            camera.position.set(40, 40, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true }); 
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.appendChild(renderer.domElement);

            // Lighting: Enhanced Setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            scene.add(camera); 
            const camLight = new THREE.DirectionalLight(0xffffff, 1.8); 
            camLight.position.set(0, 0, 1); 
            camera.add(camLight);

            const fillLights = [
                { pos: [50, 100, 50], intensity: 1.5 },   
                { pos: [-50, 20, -50], intensity: 1.0 },  
                { pos: [0, -50, 0], intensity: 1.2 },     
                { pos: [-50, 50, 50], intensity: 0.8 }    
            ];
            
            fillLights.forEach(cfg => {
                const light = new THREE.DirectionalLight(0xffffff, cfg.intensity);
                light.position.set(...cfg.pos);
                scene.add(light);
            });
            
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
            hemiLight.position.set(0, 200, 0);
            scene.add(hemiLight);

            // Controls
            orbitControls = new OrbitControls(camera, renderer.domElement);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.screenSpacePanning = true; 
            orbitControls.addEventListener('change', () => logInteraction('camera_move'));
            orbitControls.enabled = false;

            arcballControls = new ArcballControls(camera, renderer.domElement, scene);
            arcballControls.setGizmosVisible(false); 
            arcballControls.addEventListener('change', () => logInteraction('camera_move'));
            arcballControls.enabled = true; // Default Active

            currentControls = arcballControls; 
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            generateComplexBuilding(false);

            // Event Listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousedown', onMouseDown); 
            window.addEventListener('mouseup', onMouseUp); 
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);
            window.addEventListener('dblclick', onDoubleClick); 
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);

            safeBind('start-experiment-btn', 'click', startExperimentCheck);
            safeBind('demo-model-btn', 'click', loadDemoAndStart);
            safeBind('init-file-input', 'change', handleInitFileUpload);
            safeBind('gen-defect-btn', 'click', () => generateComplexBuilding(true));
            safeBind('toggle-ctrl-btn', 'click', toggleControlMode); 
            safeBind('undo-btn', 'click', performUndo);
            safeBind('next-stage-btn', 'click', advanceStage);
            safeBind('export-btn', 'click', exportData); 
            safeBind('final-export-btn', 'click', exportData); 
            safeBind('export-obj-btn', 'click', exportOBJ);
            safeBind('export-json-btn', 'click', exportData);
            safeBind('file-input', 'change', handleFileUpload);
            safeBind('toggle-mode-btn', 'click', toggleDisplayMode);
            safeBind('toggle-opacity-btn', 'click', toggleOpacityMode);
            safeBind('toggle-bg-btn', 'click', toggleBackground);
            
            // View presets
            safeBind('view-top', 'click', () => setView('top'));
            safeBind('view-bottom', 'click', () => setView('bottom'));
            safeBind('view-front', 'click', () => setView('front'));
            safeBind('view-back', 'click', () => setView('back'));
            safeBind('view-left', 'click', () => setView('left'));
            safeBind('view-right', 'click', () => setView('right'));
            
            safeBind('btn-show-analysis', 'click', finishExperiment);
            safeBind('close-analysis', 'click', () => document.getElementById('analysis-overlay').style.display = 'none');

            // Viz Toggles
            safeBind('viz-traj', 'change', (e) => { if(trajLines) trajLines.visible = e.target.checked; });
            safeBind('viz-markers', 'change', (e) => { if(actionMarkersGroup) actionMarkersGroup.visible = e.target.checked; });
            safeBind('viz-gaze', 'change', (e) => { if(gazeSpheresGroup) gazeSpheresGroup.visible = e.target.checked; });
            safeBind('viz-seq', 'change', (e) => { if(seqTextGroup) seqTextGroup.visible = e.target.checked; });
            
            safeBind('viz-mode-default', 'click', () => recolorMesh('default'));
            safeBind('viz-mode-stage', 'click', () => recolorMesh('stage'));
            safeBind('viz-mode-hesitation', 'click', () => recolorMesh('hesitation'));
            safeBind('viz-mode-conf', 'click', () => recolorMesh('confidence'));

            document.getElementById('confidence-slider').addEventListener('input', (e) => { confDisplay.innerText = e.target.value + '%'; });

            const toolBtns = {
                point: document.getElementById('tool-point'),
                brush: document.getElementById('tool-brush'),
                wand: document.getElementById('tool-wand')
            };

            Object.keys(toolBtns).forEach(key => {
                toolBtns[key].addEventListener('click', () => setTool(key));
            });
            
            brushSizeInput.addEventListener('input', (e) => {
                brushRadius = parseFloat(e.target.value);
                brushSizeVal.innerText = brushRadius.toFixed(1);
            });
            
            wandAngleInput.addEventListener('input', (e) => {
                wandAngleThreshold = parseInt(e.target.value);
            });
        }

        // --- View Preset Logic ---
        function setView(type) {
            if (!currentMesh) return;
            // Calculate center and size
            const box = new THREE.Box3().setFromObject(currentMesh);
            const center = new THREE.Vector3();
            box.getCenter(center);
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const dist = maxDim * 1.5;

            let pos = new THREE.Vector3();
            let up = new THREE.Vector3(0, 1, 0); // Default up

            switch(type) {
                case 'top': 
                    pos.set(0, dist, 0).add(center); 
                    up.set(0, 0, -1); 
                    break;
                case 'bottom': 
                    pos.set(0, -dist, 0).add(center); 
                    up.set(0, 0, 1);
                    break;
                case 'front': 
                    pos.set(0, 0, dist).add(center); 
                    break;
                case 'back': 
                    pos.set(0, 0, -dist).add(center); 
                    break;
                case 'left': 
                    pos.set(-dist, 0, 0).add(center); 
                    break;
                case 'right': 
                    pos.set(dist, 0, 0).add(center); 
                    break;
            }
            
            animateFocus(center, pos, up);
            logInteraction('view_preset', { type: type });
        }

        // --- Analysis & Visualization ---
        function finishExperiment() {
            logInteraction('experiment_end');
            
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('bottom-bar').style.display = 'none';
            document.getElementById('analysis-overlay').style.display = 'block';
            
            visualizeTrajectory();
            visualizeActions();
            visualizeGazeAndSeq();
            
            forceDisplayMode(1);
            alert("å®éªŒå®Œæˆï¼æ‚¨ç°åœ¨å¯ä»¥æŸ¥çœ‹äº¤äº’è½¨è¿¹å’Œè®¤çŸ¥çƒ­åŠ›å›¾ã€‚");
        }

        function visualizeTrajectory() {
            if (trajLines) scene.remove(trajLines);
            const points = [];
            const colors = [];
            const logs = experimentConfig.logs.filter(l => l.a === 'camera_move');
            if (logs.length < 2) return;

            const totalTime = logs[logs.length-1].t - logs[0].t;
            logs.forEach((l, i) => {
                points.push(new THREE.Vector3(...l.cam.p));
                const t = totalTime > 0 ? (l.t - logs[0].t) / totalTime : 0;
                colors.push(t, 0.5, 1-t);
            });
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 2, opacity: 0.6, transparent: true });
            trajLines = new THREE.Line(geometry, material);
            scene.add(trajLines);
        }

        function visualizeActions() {
            if (actionMarkersGroup) scene.remove(actionMarkersGroup);
            actionMarkersGroup = new THREE.Group();
            const addLog = experimentConfig.logs.filter(l => l.a === 'mark_add');
            const markerGeo = new THREE.ConeGeometry(0.5, 1.5, 8);
            markerGeo.rotateX(Math.PI / 2); 
            const markerMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });

            addLog.forEach(l => {
                const mesh = new THREE.Mesh(markerGeo, markerMat);
                mesh.position.set(...l.cam.p);
                mesh.lookAt(new THREE.Vector3(...l.cam.t));
                actionMarkersGroup.add(mesh);
            });
            scene.add(actionMarkersGroup);
        }

        function visualizeGazeAndSeq() {
            if (gazeSpheresGroup) scene.remove(gazeSpheresGroup);
            if (seqTextGroup) scene.remove(seqTextGroup);
            gazeSpheresGroup = new THREE.Group();
            seqTextGroup = new THREE.Group();

            const logs = experimentConfig.logs;
            const addLog = logs.filter(l => l.a === 'mark_add');
            
            addLog.forEach((l, index) => {
                const sprite = createTextSprite((index + 1).toString());
                sprite.position.set(...l.cam.p);
                sprite.position.y += 2.0; 
                seqTextGroup.add(sprite);
            });

            const camLogs = logs.filter(l => l.a === 'camera_move');
            const thresholdTime = 1000; 
            const thresholdDist = 1.0; 
            
            for(let i=0; i<camLogs.length-1; i++) {
                const curr = camLogs[i];
                const next = camLogs[i+1];
                const dt = next.t - curr.t;
                
                if (dt > thresholdTime) {
                    const p1 = new THREE.Vector3(...curr.cam.p);
                    const p2 = new THREE.Vector3(...next.cam.p);
                    if (p1.distanceTo(p2) < thresholdDist) {
                        const size = Math.min(dt / 2000, 3.0); 
                        const sphere = new THREE.Mesh(
                            new THREE.SphereGeometry(size, 8, 8),
                            new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.4 })
                        );
                        sphere.position.copy(p1);
                        gazeSpheresGroup.add(sphere);
                    }
                }
            }
            scene.add(seqTextGroup);
            scene.add(gazeSpheresGroup);
        }

        function recolorMesh(mode) {
            if (!currentMesh) return;
            const colorAttr = currentMesh.geometry.attributes.color;
            const count = colorAttr.count;
            const faceCount = count / 3;
            const legend = document.getElementById('legend-stage');
            legend.style.display = (mode === 'stage') ? 'flex' : 'none';

            for (let f = 0; f < faceCount; f++) {
                if (annotationData[f] && annotationData[f].marked) {
                    const data = annotationData[f];
                    let r = 1, g = 0, b = 0; 
                    if (mode === 'stage') {
                        if (data.createdInStage === 1) { r=0; g=0; b=1; }
                        else if (data.createdInStage === 2) { r=0; g=1; b=0; }
                        else { r=1; g=0; b=0; }
                    } 
                    else if (mode === 'confidence') {
                        const t = data.confidence / 100;
                        r = 1.0; g = 1.0 - t; b = 0;
                    }
                    else if (mode === 'hesitation') {
                         const t = Math.min(data.decisionTime / 3000, 1.0);
                         r = t * 0.5; g = 1-t; b = 1-t * 0.5;
                    }
                    for(let k=0; k<3; k++) colorAttr.setXYZ(f*3+k, r, g, b);
                } else {
                    for(let k=0; k<3; k++) colorAttr.setXYZ(f*3+k, 0.8, 0.8, 0.8);
                }
            }
            colorAttr.needsUpdate = true;
        }

        // --- Experiment Logic ---

        function startExperimentCheck() {
            const userIdInput = document.getElementById('user-id-input');
            if (userIdInput.value.trim() === "") { alert("è¯·è¾“å…¥å‚ä¸è€… IDï¼"); return; }
            if (currentMesh) startExperiment();
            else document.getElementById('init-file-input').click();
        }

        function handleInitFileUpload(event) {
            const userIdInput = document.getElementById('user-id-input');
            if (userIdInput.value.trim() === "") {
                alert("è¯·å…ˆè¾“å…¥å‚ä¸è€… IDï¼"); event.target.value = ''; return;
            }
            autoStartExperiment = true; handleFileUpload(event); 
        }

        function loadDemoAndStart() {
            const userIdInput = document.getElementById('user-id-input');
            if (userIdInput.value.trim() === "") { alert("è¯·è¾“å…¥å‚ä¸è€… IDï¼"); return; }
            autoStartExperiment = true; generateComplexBuilding(true); 
        }

        function startExperiment() {
            const userIdInput = document.getElementById('user-id-input');
            experimentConfig.userId = userIdInput.value.trim();
            experimentConfig.startTime = new Date().toISOString();
            experimentConfig.logs = []; 
            document.getElementById('login-overlay').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            document.getElementById('bottom-bar').style.display = 'flex';
            setStage(1);
            logInteraction('experiment_start', { model: 'loaded_model' });
        }

        function setStage(stageNum) {
            experimentConfig.currentStage = stageNum;
            document.querySelectorAll('.stage-step').forEach(el => el.classList.remove('active'));
            document.getElementById(`step-${stageNum}`).classList.add('active');
            
            const stageTitle = document.getElementById('stage-title');
            const stageDesc = document.getElementById('stage-desc');
            const nextStageBtn = document.getElementById('next-stage-btn');
            const exportBtn = document.getElementById('export-btn');

            if (stageNum === 1) {
                stageTitle.innerText = "é˜¶æ®µ 1: çº¯å‡ ä½•è§‚å¯Ÿ"; stageDesc.innerText = "è¯·ä»…æ ¹æ®å‡ ä½•ç»“æ„ï¼ˆç™½æ¨¡ï¼‰æ ‡è®°æ¨¡å‹ç¼ºé™·ã€‚å¿½ç•¥çº¹ç†ä¿¡æ¯ã€‚"; forceDisplayMode(2); 
            } else if (stageNum === 2) {
                stageTitle.innerText = "é˜¶æ®µ 2: çº¹ç†è§‚å¯Ÿ"; stageDesc.innerText = "æ¨¡å‹å·²åˆ‡æ¢ä¸ºçº¯çº¹ç†æ¨¡å¼ã€‚è¯·æ£€æŸ¥æ˜¯å¦æœ‰çº¹ç†æ‹‰ä¼¸ã€æ¨¡ç³Šæˆ–é”™ä½ã€‚"; forceDisplayMode(0); 
            } else if (stageNum === 3) {
                stageTitle.innerText = "é˜¶æ®µ 3: ç»¼åˆæ ¡éªŒ"; stageDesc.innerText = "å åŠ å‡ ä½•çº¿æ¡†ã€‚è¯·ç»¼åˆåˆ¤æ–­å¹¶ä¿®æ­£ä¹‹å‰çš„æ ‡è®°ã€‚"; forceDisplayMode(1); 
                nextStageBtn.innerText = "ğŸ å®Œæˆå®éªŒå¹¶åˆ†æ"; 
            }
            logInteraction('stage_change', { stage: stageNum });
            updateUIStats();
        }

        function advanceStage() {
            if (experimentConfig.currentStage < 3) {
                setStage(experimentConfig.currentStage + 1);
            } else {
                finishExperiment();
            }
        }

        function forceDisplayMode(mode) {
            if (!currentMesh) return;
            displayMode = mode;
            const materials = Array.isArray(currentMesh.material) ? currentMesh.material : [currentMesh.material];
            const wireMesh = currentMesh.children.find(c => c.isMesh && c.material.wireframe);
            const hasBackup = materials.some(m => !!m.userData.originalMap);
            if (!hasBackup && mode !== 2) { displayMode = 2; mode = 2; }
            switch (mode) {
                case 0: materials.forEach(m => { if (m.userData.originalMap) { m.map = m.userData.originalMap; m.needsUpdate = true; } }); if (wireMesh) wireMesh.material.opacity = 0.01; refreshColors(true); break;
                case 1: materials.forEach(m => { if (m.userData.originalMap) { m.map = m.userData.originalMap; m.needsUpdate = true; } }); if (wireMesh) wireMesh.material.opacity = 0.2; refreshColors(true); break;
                case 2: materials.forEach(m => { if (m.map) m.userData.originalMap = m.map; m.map = null; m.needsUpdate = true; }); if (wireMesh) wireMesh.material.opacity = 0.15; refreshColors(false); break;
            }
        }

        // --- Tool & Logic ---
        function setTool(toolName) {
            currentTool = toolName;
            const toolBtns = { point: document.getElementById('tool-point'), brush: document.getElementById('tool-brush'), wand: document.getElementById('tool-wand') };
            Object.keys(toolBtns).forEach(key => {
                if (key === toolName) toolBtns[key].classList.add('active'); else toolBtns[key].classList.remove('active');
            });
            document.getElementById('param-brush').style.display = (toolName === 'brush') ? 'flex' : 'none';
            document.getElementById('param-wand').style.display = (toolName === 'wand') ? 'flex' : 'none';
            const brushCursor = document.getElementById('brush-cursor');
            if (toolName === 'brush') { brushCursor.style.display = 'block'; document.body.style.cursor = 'none'; } else { brushCursor.style.display = 'none'; document.body.style.cursor = 'default'; }
        }

        function buildAdjacencyGraph(geometry) {
            const posAttr = geometry.attributes.position;
            const count = posAttr.count;
            const faceCount = count / 3;
            const vHashToFaces = new Map();
            const precision = 1000; 
            for (let f = 0; f < faceCount; f++) {
                for (let k = 0; k < 3; k++) {
                    const idx = f * 3 + k;
                    const x = Math.round(posAttr.getX(idx) * precision); const y = Math.round(posAttr.getY(idx) * precision); const z = Math.round(posAttr.getZ(idx) * precision);
                    const key = `${x},${y},${z}`;
                    if (!vHashToFaces.has(key)) vHashToFaces.set(key, []);
                    vHashToFaces.get(key).push(f);
                }
            }
            adjacencyMap = new Array(faceCount);
            for (let f = 0; f < faceCount; f++) {
                const neighbors = new Set();
                for (let k = 0; k < 3; k++) {
                    const idx = f * 3 + k;
                    const x = Math.round(posAttr.getX(idx) * precision); const y = Math.round(posAttr.getY(idx) * precision); const z = Math.round(posAttr.getZ(idx) * precision);
                    const key = `${x},${y},${z}`;
                    const sharingFaces = vHashToFaces.get(key);
                    for (let sf of sharingFaces) { if (sf !== f) neighbors.add(sf); }
                }
                adjacencyMap[f] = Array.from(neighbors);
            }
        }

        function magicWandSelect(startFaceIndex, isDeletion = false) {
            if (!adjacencyMap) { alert("æ­£åœ¨æ„å»ºæ‹“æ‰‘ç»“æ„..."); return; }
            const visited = new Set();
            const queue = [startFaceIndex];
            const selectedFaces = [];
            visited.add(startFaceIndex);
            
            const normalAttr = currentMesh.geometry.attributes.normal;
            const getFaceNormal = (fIdx) => new THREE.Vector3().fromBufferAttribute(normalAttr, fIdx * 3);
            const startNormal = getFaceNormal(startFaceIndex);
            const thresholdDot = Math.cos(THREE.MathUtils.degToRad(wandAngleThreshold));
            
            while(queue.length > 0) {
                const currentF = queue.shift();
                selectedFaces.push(currentF);
                const neighbors = adjacencyMap[currentF];
                if (!neighbors) continue;
                for (let neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        const neighborNormal = getFaceNormal(neighbor);
                        if (startNormal.dot(neighborNormal) >= thresholdDot) {
                            visited.add(neighbor); queue.push(neighbor);
                        }
                    }
                }
            }
            batchMarkFaces(selectedFaces, isDeletion);
            const focusMsg = document.getElementById('focus-msg');
            focusMsg.innerText = isDeletion ? `ğŸ§¹ æ¶ˆé™¤ ${selectedFaces.length} ä¸ªé¢ç‰‡` : `ğŸª„ é€‰ä¸­ ${selectedFaces.length} ä¸ªé¢ç‰‡`;
            focusMsg.style.opacity = 1; setTimeout(() => focusMsg.style.opacity = 0, 1500);
        }

        function brushSelect(centerPoint, isDeletion = false) {
            const posAttr = currentMesh.geometry.attributes.position;
            const faceCount = posAttr.count / 3;
            const rSq = brushRadius * brushRadius;
            const selectedFaces = [];
            const p1 = new THREE.Vector3(), p2 = new THREE.Vector3(), p3 = new THREE.Vector3(), center = new THREE.Vector3();
            const localPoint = centerPoint.clone().applyMatrix4(currentMesh.matrixWorld.clone().invert());

            for (let f = 0; f < faceCount; f++) {
                p1.fromBufferAttribute(posAttr, f*3); p2.fromBufferAttribute(posAttr, f*3+1); p3.fromBufferAttribute(posAttr, f*3+2);
                center.addVectors(p1, p2).add(p3).divideScalar(3);
                if (center.distanceToSquared(localPoint) <= rSq) selectedFaces.push(f);
            }
            batchMarkFaces(selectedFaces, isDeletion);
        }

        function batchMarkFaces(faceIndices, isDeletion = false) {
            const confidence = parseInt(document.getElementById('confidence-slider').value);
            const intensity = 0.5 + (confidence / 200);
            const colorAttr = currentMesh.geometry.attributes.color;
            const posAttr = currentMesh.geometry.attributes.position;
            const normalAttr = currentMesh.geometry.attributes.normal;
            const actionChanges = []; 
            const stage = experimentConfig.currentStage;
            const isTexture = displayMode !== 2;
            const baseVal = isTexture ? 1.0 : 0.66;
            const pA = new THREE.Vector3(), pB = new THREE.Vector3(), pC = new THREE.Vector3();
            const center = new THREE.Vector3(), normal = new THREE.Vector3(), viewDir = new THREE.Vector3();

            faceIndices.forEach(fIdx => {
                if (isDeletion) {
                    if (annotationData[fIdx]) {
                        actionChanges.push({ faceIndex: fIdx, oldState: {...annotationData[fIdx]} });
                        delete annotationData[fIdx];
                        for(let i=0; i<3; i++) colorAttr.setXYZ(fIdx*3+i, baseVal, baseVal, baseVal);
                    }
                } else {
                    if (!annotationData[fIdx] || !annotationData[fIdx].marked) {
                        actionChanges.push({ faceIndex: fIdx, oldState: null });
                        
                        pA.fromBufferAttribute(posAttr, fIdx*3); pB.fromBufferAttribute(posAttr, fIdx*3+1); pC.fromBufferAttribute(posAttr, fIdx*3+2);
                        center.addVectors(pA, pB).add(pC).divideScalar(3); center.applyMatrix4(currentMesh.matrixWorld);
                        const distToCam = camera.position.distanceTo(center);
                        const screenPos = center.clone().project(camera);
                        const screenDist = new THREE.Vector2(screenPos.x, screenPos.y).length();
                        normal.fromBufferAttribute(normalAttr, fIdx*3);
                        normal.applyMatrix3(new THREE.Matrix3().getNormalMatrix(currentMesh.matrixWorld)).normalize();
                        viewDir.subVectors(camera.position, center).normalize();
                        const dot = normal.dot(viewDir);

                        annotationData[fIdx] = {
                            marked: true, createdInStage: stage, confidence: confidence, timestamp: Date.now(), decisionTime: Date.now() - hoverStartTime,
                            viewAngle: dot.toFixed(3), cameraDist: distToCam.toFixed(3), screenCentricity: screenDist.toFixed(3)
                        };
                        for(let i=0; i<3; i++) colorAttr.setXYZ(fIdx*3+i, 1 * intensity, 0.2, 0.2); 
                    }
                }
            });

            if (actionChanges.length > 0) {
                undoStack.push(actionChanges);
                logInteraction(isDeletion ? 'mark_delete' : 'mark_add', { count: faceIndices.length, tool: currentTool });
                document.getElementById('undo-btn').disabled = false;
                colorAttr.needsUpdate = true;
                updateUIStats();
            }
        }

        // --- Interaction ---
        function onMouseDown(event) {
            mouseDownPosition.set(event.clientX, event.clientY);
            if (currentTool !== 'point' && currentMesh) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(currentMesh);
                if (intersects.length > 0) {
                    isInteractWithModel = true;
                    currentControls.enabled = false; 
                    if (currentTool === 'brush') brushSelect(intersects[0].point, event.shiftKey);
                } else { isInteractWithModel = false; }
            }
        }

        function onMouseUp(event) {
            currentControls.enabled = true; 
            isInteractWithModel = false;
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            const brushCursor = document.getElementById('brush-cursor');
            const cursorFeedback = document.getElementById('cursor-feedback');

            if (currentTool === 'brush') {
                brushCursor.style.left = event.clientX + 'px';
                brushCursor.style.top = event.clientY + 'px';
                const scale = 50 * brushRadius / camera.position.distanceTo(new THREE.Vector3(0,0,0)) * 10;
                brushCursor.style.width = Math.max(20, scale) + 'px'; brushCursor.style.height = Math.max(20, scale) + 'px';
                if (event.shiftKey) { brushCursor.style.borderColor = "white"; brushCursor.style.backgroundColor = "rgba(255, 255, 255, 0.2)"; } 
                else { brushCursor.style.borderColor = "rgba(0, 210, 255, 0.8)"; brushCursor.style.backgroundColor = "rgba(0, 210, 255, 0.1)"; }
            } else { cursorFeedback.style.left = event.clientX + 15 + 'px'; cursorFeedback.style.top = event.clientY + 15 + 'px'; }

            if (!currentMesh) return;
            if (isInteractWithModel && event.buttons === 1) {
                if (currentTool === 'brush') {
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObject(currentMesh);
                    if (intersects.length > 0) brushSelect(intersects[0].point, event.shiftKey);
                }
                return; 
            }
            if (!isInteractWithModel) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(currentMesh);
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const faceIndex = intersect.faceIndex;
                    if (faceIndex !== hoveredFaceIndex) {
                        if (hoveredFaceIndex !== -1 && currentTool === 'point') highlightFace(hoveredFaceIndex, false);
                        hoveredFaceIndex = faceIndex;
                        hoverStartTime = Date.now();
                        if (currentTool === 'point') { cursorFeedback.style.display = 'block'; cursorFeedback.innerText = "Face: " + faceIndex; highlightFace(faceIndex, true); }
                    }
                    if (currentTool === 'point' && event.buttons === 1 && event.ctrlKey) batchMarkFaces([faceIndex], event.shiftKey);
                } else {
                    if (hoveredFaceIndex !== -1 && currentTool === 'point') highlightFace(hoveredFaceIndex, false);
                    hoveredFaceIndex = -1;
                    cursorFeedback.style.display = 'none';
                }
            }
        }

        function onMouseClick(event) {
            if (hoveredFaceIndex === -1 || !currentMesh) return;
            if (event.target.closest('#ui-layer') || event.target.closest('#bottom-bar')) return;
            const moveDist = Math.abs(event.clientX - mouseDownPosition.x) + Math.abs(event.clientY - mouseDownPosition.y);
            if (moveDist > 5) return;
            if (currentTool === 'point') batchMarkFaces([hoveredFaceIndex], event.shiftKey);
            else if (currentTool === 'wand') magicWandSelect(hoveredFaceIndex, event.shiftKey);
        }

        function highlightFace(idx, show) {
            if (annotationData[idx]) return; 
            const attr = currentMesh.geometry.attributes.color;
            const r = show ? 0 : (displayMode===2 ? 0.66 : 1.0); 
            const g = show ? 0.8 : (displayMode===2 ? 0.66 : 1.0);
            const b = show ? 1 : (displayMode===2 ? 0.66 : 1.0);
            for(let i=0; i<3; i++) attr.setXYZ(idx*3+i, r, g, b);
            attr.needsUpdate = true;
        }

        // --- Other Funcs ---
        function performUndo() {
            if (undoStack.length === 0) return;
            const lastAction = undoStack.pop();
            const colorAttr = currentMesh.geometry.attributes.color;
            const isTexture = displayMode !== 2;
            const baseVal = isTexture ? 1.0 : 0.66; 
            lastAction.forEach(change => {
                const fIdx = change.faceIndex;
                if (change.oldState === null) {
                    delete annotationData[fIdx];
                    for(let i=0; i<3; i++) colorAttr.setXYZ(fIdx*3+i, baseVal, baseVal, baseVal);
                } else {
                    annotationData[fIdx] = change.oldState;
                    const conf = change.oldState.confidence;
                    const intensity = 0.5 + (conf / 200);
                    for(let i=0; i<3; i++) colorAttr.setXYZ(fIdx*3+i, 1 * intensity, 0.2, 0.2);
                }
            });
            logInteraction('undo');
            colorAttr.needsUpdate = true;
            updateUIStats();
            document.getElementById('undo-btn').disabled = undoStack.length === 0;
        }

        function toggleBackground() {
            if (!scene) return;
            isDarkBackground = !isDarkBackground;
            scene.background = new THREE.Color(isDarkBackground ? 0x222222 : 0xffffff);
            const btn = document.getElementById('toggle-bg-btn');
            if (btn) btn.innerText = isDarkBackground ? "ğŸ¨ èƒŒæ™¯: æ·±è‰²" : "ğŸ¨ èƒŒæ™¯: æµ…è‰²";
        }

        function refreshColors(isTextureMode) {
            if (!currentMesh) return;
            const colorAttr = currentMesh.geometry.attributes.color;
            const count = colorAttr.count;
            const faceCount = count / 3;
            const baseVal = (isTextureMode === true) ? 1.0 : 0.66;
            for (let f = 0; f < faceCount; f++) {
                if (annotationData[f] && annotationData[f].marked) {
                    const data = annotationData[f];
                    const t = data.confidence / 100;
                    const intensity = 0.5 + (t / 2.0); 
                    for(let k=0; k<3; k++) colorAttr.setXYZ(f*3+k, 1 * intensity, 0.2, 0.2);
                } else {
                    for(let k=0; k<3; k++) colorAttr.setXYZ(f*3+k, baseVal, baseVal, baseVal);
                }
            }
            colorAttr.needsUpdate = true;
        }

        function toggleControlMode() {
            const toggleCtrlBtn = document.getElementById('toggle-ctrl-btn');
            const focusMsg = document.getElementById('focus-msg');
            if (currentControls === orbitControls) {
                orbitControls.enabled = false;
                arcballControls.enabled = true;
                arcballControls.target.copy(orbitControls.target); 
                arcballControls.update(); 
                currentControls = arcballControls;
                toggleCtrlBtn.innerText = "ğŸ•¹ï¸ è§†è§’ï¼šè‡ªç”± (3è½´)";
                focusMsg.innerText = "ğŸ”„ è¿›å…¥3è½´è‡ªç”±æ—‹è½¬æ¨¡å¼";
                focusMsg.style.opacity = 1; setTimeout(() => { focusMsg.style.opacity = 0; focusMsg.innerText = "ğŸ¯ è§†è§’å·²èšç„¦"; }, 1500);
            } else {
                arcballControls.enabled = false;
                orbitControls.enabled = true;
                orbitControls.target.copy(arcballControls.target); 
                camera.up.set(0, 1, 0);
                orbitControls.update();
                currentControls = orbitControls;
                toggleCtrlBtn.innerText = "ğŸ•¹ï¸ è§†è§’ï¼šå»ºç­‘ (2è½´)";
            }
        }

        function toggleOpacityMode() {
            if (!currentMesh) return;
            const materials = Array.isArray(currentMesh.material) ? currentMesh.material : [currentMesh.material];
            const isTransparent = materials[0].transparent;
            const newState = !isTransparent;
            materials.forEach(m => { m.transparent = newState; m.opacity = newState ? 0.5 : 1.0; m.needsUpdate = true; });
            document.getElementById('toggle-opacity-btn').innerText = newState ? "ğŸ’§ åŠé€æ˜: å¼€" : "ğŸ’§ åŠé€æ˜: å…³";
        }

        function toggleDisplayMode() {
            if (!currentMesh) return;
            displayMode = (displayMode + 1) % 3;
            forceDisplayMode(displayMode);
            const modeNames = ["çº¯çº¹ç†", "çº¹ç†+ç½‘æ ¼", "çº¯ç½‘æ ¼"];
            document.getElementById('toggle-mode-btn').innerText = "ğŸ‘ï¸ æ˜¾ç¤ºï¼š" + modeNames[displayMode];
        }

        function onDoubleClick(event) {
            if (hoveredFaceIndex === -1 || !currentMesh) return;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(currentMesh);
            if (intersects.length > 0) {
                const targetPoint = intersects[0].point;
                const faceNormal = intersects[0].face.normal.clone().transformDirection(currentMesh.matrixWorld).normalize();
                const distance = camera.position.distanceTo(targetPoint);
                const newCamPos = targetPoint.clone().add(faceNormal.multiplyScalar(distance * 0.5)); 
                animateFocus(targetPoint, newCamPos, new THREE.Vector3(0, 1, 0)); // Use default up
                const focusMsg = document.getElementById('focus-msg');
                focusMsg.style.opacity = 1; setTimeout(() => focusMsg.style.opacity = 0, 1500);
            }
        }

        function animateFocus(targetPos, camPos, upVec = null) {
            focusTargetPos.copy(targetPos);
            focusCameraPos.copy(camPos);
            if(upVec) focusCameraUp = upVec; // Use provided up vector
            else focusCameraUp.copy(camera.up);
            isFocusing = true;
        }

        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;
            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.style.display = 'flex';
            document.getElementById('toggle-opacity-btn').innerText = "ğŸ’§ åŠé€æ˜: å…³";
            undoStack = []; updateUndoButton();
            objectURLs.forEach(url => URL.revokeObjectURL(url)); objectURLs = [];
            const fileMap = new Map();
            let objFile = null, mtlFile = null, glbFile = null;
            for(let i=0; i<files.length; i++) {
                const file = files[i]; const url = URL.createObjectURL(file); objectURLs.push(url); fileMap.set(file.name, url);
                const lower = file.name.toLowerCase();
                if (lower.endsWith('.obj')) objFile = file.name; if (lower.endsWith('.mtl')) mtlFile = file.name; if (lower.endsWith('.glb') || lower.endsWith('.gltf')) glbFile = file.name;
            }
            const manager = new THREE.LoadingManager();
            manager.setURLModifier((url) => { const n = url.split('/').pop().split('\\').pop(); return fileMap.has(n) ? fileMap.get(n) : url; });
            if (glbFile) {
                const loader = new GLTFLoader(manager); const dracoLoader = new DRACOLoader(); dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/'); loader.setDRACOLoader(dracoLoader);
                loader.load(fileMap.get(glbFile), (gltf) => handleLoadedObject(gltf.scene), undefined, err => { console.error(err); alert("GLB Error"); loadingOverlay.style.display='none'; });
            } else if (objFile) {
                const objLoader = new OBJLoader(manager); const onLoadObj = (object) => { handleLoadedObject(object); };
                if (mtlFile) { new MTLLoader(manager).load(fileMap.get(mtlFile), mats => { mats.preload(); objLoader.setMaterials(mats); objLoader.load(fileMap.get(objFile), onLoadObj, undefined, err => { console.error(err); alert("OBJ Error"); loadingOverlay.style.display='none'; }); });
                } else { objLoader.load(fileMap.get(objFile), handleLoadedObject, undefined, err => { console.error(err); alert("OBJ Error"); loadingOverlay.style.display='none'; }); }
            } else { alert("æœªæ‰¾åˆ°æ¨¡å‹æ–‡ä»¶"); loadingOverlay.style.display='none'; }
        }

        function handleLoadedObject(object) {
            const geometries = []; const materials = [];
            object.updateMatrixWorld(true);
            object.traverse((child) => {
                if (child.isMesh) {
                    const clonedGeo = child.geometry.clone();
                    clonedGeo.applyMatrix4(child.matrixWorld);
                    geometries.push(clonedGeo);
                    if (child.material) { if (Array.isArray(child.material)) materials.push(...child.material); else materials.push(child.material); } else { materials.push(new THREE.MeshStandardMaterial({color: 0xcccccc})); }
                }
            });
            if (geometries.length === 0) { alert("No mesh found"); document.getElementById('loading-overlay').style.display='none'; return; }
            const mergedGeo = BufferGeometryUtils.mergeGeometries(geometries, true).toNonIndexed();
            processGeometry(mergedGeo, materials);
        }

        function generateComplexBuilding(injectDefects = true) {
            const loadingOverlay = document.getElementById('loading-overlay');
            loadingOverlay.style.display = 'flex';
            setTimeout(() => {
                const geometries = []; const helper = new THREE.Object3D();
                let currentY = 0; const baseWidth = 15; const baseDepth = 15; const segDensity = 1.2; 
                const podiumHeight = 4; const podiumGeo = new THREE.BoxGeometry(baseWidth, podiumHeight, baseDepth, Math.ceil(baseWidth*segDensity), Math.ceil(podiumHeight*segDensity), Math.ceil(baseDepth*segDensity));
                helper.position.set(0, currentY + podiumHeight/2, 0); helper.updateMatrixWorld(); podiumGeo.applyMatrix4(helper.matrixWorld); geometries.push(podiumGeo);
                
                let segments = 3; let currentWidth = baseWidth * 0.85; let currentDepth = baseDepth * 0.85;
                for(let i=0; i<segments; i++) {
                    const height = 8;
                    let geo = new THREE.BoxGeometry(currentWidth, height, currentDepth, Math.ceil(currentWidth*segDensity), Math.ceil(height*segDensity), Math.ceil(currentDepth*segDensity));
                    helper.position.set(0, currentY + height/2 + 2, 0); helper.updateMatrixWorld(); geo.applyMatrix4(helper.matrixWorld); geometries.push(geo);
                    currentY += height; currentWidth *= 0.8; currentDepth *= 0.8;
                }

                let mergedGeo = BufferGeometryUtils.mergeGeometries(geometries, true).toNonIndexed(); 
                // Noise
                const posAttr = mergedGeo.attributes.position;
                for(let i=0; i<posAttr.count; i++) {
                    const y = posAttr.getY(i);
                    // CHECK NaN
                    if (!isNaN(y)) posAttr.setY(i, y + (Math.random()-0.5)*0.2);
                }
                mergedGeo.computeVertexNormals();
                const materials = [new THREE.MeshStandardMaterial({vertexColors: true})];
                processGeometry(mergedGeo, materials);
                if (document.getElementById('login-overlay').style.display !== 'none') { /* Wait */ } else { startExperiment(); }
                loadingOverlay.style.display = 'none';
            }, 50);
        }

        function processGeometry(geometry, materials) {
            if(currentMesh) { scene.remove(currentMesh); if(currentMesh.geometry) currentMesh.geometry.dispose(); currentMesh = null; }
            if (geometry.index !== null) geometry = geometry.toNonIndexed();
            
            cleanGeometry(geometry); // Clean NaNs

            geometry.center(); geometry.computeVertexNormals(); geometry.computeBoundingBox();
            buildAdjacencyGraph(geometry);
            const size = new THREE.Vector3(); geometry.boundingBox.getSize(size);
            const maxDim = Math.max(size.x, size.y, size.z);
            let cameraZ = Math.abs(maxDim / 2 * Math.tan(camera.fov * Math.PI / 180 * 2)) * 1.3;
            camera.position.set(cameraZ, cameraZ*0.5, cameraZ); camera.lookAt(0,0,0);
            orbitControls.target.set(0,0,0); arcballControls.target.set(0,0,0); currentControls.update();
            const matArray = Array.isArray(materials) ? materials : [materials];
            matArray.forEach(m => { 
                if(!m) return;
                m.vertexColors = true; m.flatShading = false; m.side = THREE.DoubleSide; m.alphaTest = 0.5; if(m.map) { m.userData.originalMap = m.map; m.map.colorSpace = THREE.SRGBColorSpace; } 
            });
            
            const count = geometry.attributes.position.count;
            const colors = []; for(let i=0; i<count; i++) colors.push(0.66, 0.66, 0.66);
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            originalColorAttribute = geometry.attributes.color.clone(); 
            currentMesh = new THREE.Mesh(geometry, matArray);
            const wireMat = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, transparent: true, opacity: 0.03 });
            const wireMesh = new THREE.Mesh(geometry, wireMat);
            currentMesh.add(wireMesh);
            scene.add(currentMesh);
            annotationData = {}; undoStack = []; updateUndoButton(); updateUIStats();
            if (autoStartExperiment) { startExperiment(); autoStartExperiment = false; } else if (experimentConfig.currentStage === 1) { forceDisplayMode(2); }
            document.getElementById('loading-overlay').style.display='none';
        }

        function exportData() {
            const exportPayload = { meta: { userId: experimentConfig.userId, startTime: experimentConfig.startTime, endTime: new Date().toISOString(), totalStages: 3, logs: experimentConfig.logs }, annotations: annotationData };
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(exportPayload, null, 2));
            const node = document.createElement('a'); node.setAttribute("href", dataStr); node.setAttribute("download", `experiment_data_${experimentConfig.userId}_${Date.now()}.json`);
            document.body.appendChild(node); node.click(); node.remove();
        }

        function exportOBJ() {
            if (!currentMesh) { alert("æ— æ¨¡å‹å¯¼å‡º"); return; }
            const loadingOverlay = document.getElementById('loading-overlay'); loadingOverlay.style.display = 'flex';
            setTimeout(() => {
                const geo = currentMesh.geometry; const pos = geo.attributes.position; const col = geo.attributes.color;
                const lines = ["# Export"];
                for (let i = 0; i < pos.count; i++) lines.push(`v ${pos.getX(i)} ${pos.getY(i)} ${pos.getZ(i)} ${col.getX(i)} ${col.getY(i)} ${col.getZ(i)}`);
                for (let i = 0; i < pos.count; i+=3) lines.push(`f ${i+1} ${i+2} ${i+3}`);
                const blob = new Blob([lines.join('\n')], {type:'text/plain'});
                const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = "model.obj";
                link.click(); loadingOverlay.style.display = 'none';
            }, 100);
        }

        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function onKeyDown(e) { if(e.key==='Control') { currentControls.enabled=false; if(currentTool==='point') document.body.style.cursor='crosshair'; } if((e.ctrlKey||e.metaKey)&&e.key==='z') performUndo(); }
        function onKeyUp(e) { if(e.key==='Control') { currentControls.enabled=true; if(currentTool==='point') document.body.style.cursor='default'; } }
        function animate() { 
            requestAnimationFrame(animate); 
            if(currentControls.enabled) currentControls.update(); 
            if(isFocusing) { 
                camera.position.lerp(focusCameraPos, 0.05); 
                currentControls.target.lerp(focusTargetPos, 0.05);
                // Also interpolate Up vector for smooth Top/Bottom transition
                if (focusCameraUp) camera.up.lerp(focusCameraUp, 0.05);
                
                if(camera.position.distanceTo(focusCameraPos)<0.1) isFocusing=false; 
            } 
            renderer.render(scene, camera); 
        }
        function updateUIStats() { const keys = Object.keys(annotationData); document.getElementById('count-val').innerText = keys.length; const stage = experimentConfig.currentStage; const sCount = keys.filter(k => annotationData[k].createdInStage === stage).length; document.getElementById('stage-count-val').innerText = sCount; }
        function updateUndoButton() { document.getElementById('undo-btn').disabled = undoStack.length === 0; }
    </script>
</body>
</html>
